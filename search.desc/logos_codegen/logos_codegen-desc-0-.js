searchState.loadedDescShard("logos_codegen", 0, "Logos\nGenerate a <code>Logos</code> implementation for the given struct, …\nStrip all logos attributes from the given struct, allowing …\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet of functions that have already been rendered\nReturns the argument unchanged.\nReturns an identifier to a function that matches a byte to …\nLocal function calls. Note: a call might change its …\nReference to the graph with all of the nodes\nFunction name identifiers\nCalls <code>U::from(self)</code>.\nMeta data collected for the nodes\nName of the type we are implementing the <code>Logos</code> trait for\nBuffer with functions growing during generation\nId to the root node\nRelated to above, table stack manages tables that need to …\nIdentifiers for helper functions matching a byte to a given\nName of the type with any generics it might need\nThis struct keeps track of bytes available to be read …\nAmount of bytes that haven’t been bumped yet but should …\nNumber of bytes available without bound checks\nNode to backtrack to to in case an explicit match has …\nWhether or not the Lexer has been bumped at least by 1 byte\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhen attempting to merge two nodes, one of which was not …\nTrait to be implemented on <code>Leaf</code> nodes in order to …\nDisambiguation error during the attempt to merge two leaf …\nFork node, can lead to more than one state\nLeaf node, terminal state\nMerge key used to lookup whether two nodes have been …\nId of a Node in the graph. <code>NodeId</code> can be referencing an …\nUnique reserved <code>NodeId</code> that is guaranteed to point to an …\nRope node, can lead to one state on match, one state on …\nDeferred merges. When when attempting to merge a node with …\nInstead of handling errors over return types, opt to …\nIf nodes <code>a</code> and <code>b</code> have been already merged, return the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAnother map used for accounting. Before <code>.push</code>ing a new node\nInsert a node at a given, previously reserved id. Returns …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMerge the nodes at id <code>a</code> and <code>b</code>, returning a new id.\nUnchecked merge of <code>a</code> and <code>b</code>. This fn assumes that <code>a</code> and <code>b</code> …\nWhen merging two nodes into a new node, we store the two …\nInternal storage of all allocated nodes. Once a node is …\nPush a node onto the graph and get an id to it. If an …\nReserve an empty slot for a node on the graph and return an\nMark that nodes <code>a</code> and <code>b</code> have been merged into <code>product</code>.\nFind all nodes that have no references and remove them.\nChecks if all bytes in the <code>range</code> have a branch on this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLUT matching byte -&gt; node id\nState to go to if no arms are matching\nWe don’t need debug impls in release builds\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarks whether or not this node leads to a loop entry node.\nIds of other nodes that point to this node while this node …\nMinimum number of bytes that ought to be read for this …\nNumber of references to this node\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn whether current class unicode is ascii.\nReturn whether current class unicode is ascii and only …\nJump to id on partial or empty match\nJump to id if first byte does not match, fail on partial …\nBecause Ropes could potentially fail a match mid-pattern, …\nSame as Option::None, error on fail\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA set of characters represented by arbitrary bytes (one …\nThe high-level intermediate representation of a character …\nA set of characters represented by Unicode scalar values.\nThe high-level intermediate representation of a literal.\nMiddle Intermediate Representation of the regex, built from\nA set of characters represented by Unicode scalar values.\nApply Unicode simple case folding to this character class, …\nExpand this character class such that it contains all case …\nSubtract the given character class from this character …\nCreate a new class with no ranges.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIntersect this character class with the given character …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this character class will …\nReturns true if and only if this character class is empty. …\nReturns true if and only if this character class will only …\nReturn an iterator over all ranges in this class.\nIf this class consists of exactly one element (whether a …\nIf this class consists of exactly one codepoint, then …\nReturns the length, in bytes, of the longest string …\nReturns the length, in bytes, of the longest string …\nReturns the length, in bytes, of the smallest string …\nReturns the length, in bytes, of the smallest string …\nNegate this character class in place.\nNegate this character class.\nCreate a new class from a sequence of ranges.\nAdd a new range to this set.\nReturn the underlying ranges as a slice.\nCompute the symmetric difference of the given character …\nIf this class consists of only ASCII ranges, then return …\nApply Unicode simple case folding to this character class, …\nExpand this character class such that it contains all case …\nUnion this character class with the given character class, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nChecks if <code>ty</code> is a declared generic param, if so replaces it\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse attribute definition of a token:\nTry to parse the main <code>#[logos(...)]</code>, does nothing if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if this <code>IgnoreFlags</code> contains <em>any</em> of the given …\nEnables a variant.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParses an identifier an enables it for <code>self</code>.\nCreates a equivalent regular expression which ignore the …\n<code>name = ...</code>\n<code>name(...)</code>\n<code>name ident = ...</code>\n<code>name &quot;literal&quot;</code>\nNamed: name …\nUnexpected token,\nUnnamed nested attribute, such as a string, callback …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAnalog to Option, except when put into the quote! macro, …\nIf supplied <code>tt</code> is a punct matching a char, returns <code>None</code>, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")