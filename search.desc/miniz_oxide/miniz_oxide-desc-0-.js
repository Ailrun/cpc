searchState.loadedDescShard("miniz_oxide", 0, "A pure rust replacement for the miniz DEFLATE/zlib …\nNot implemented.\nBuffer-related error.\nError in inflation; see <code>inflate::stream::inflate()</code> for …\nHow compressed data is wrapped.\nContains the error value\nUnused\nAttempt to flush the remaining data and end the stream.\nSame as <code>Sync</code>, but resets the compression dictionary so …\nA list of miniz failed status codes.\nA list of flush types.\n<code>Result</code> alias for all miniz status codes both successful …\nA list of miniz successful status codes.\nUnused\nUnused\nDon’t force any flushing. Used when more input data is …\nContains the success value\nOperation succeeded.\nBad parameters.\nZlib partial flush. Currently treated as <code>Sync</code>.\nRaw DEFLATE.\nGeneral stream error.\nOperation succeeded and end of deflate stream was found.\nA structure containing the result of a call to the inflate …\nFinish compressing the currently buffered data, and output …\nUnused\nZlib wrapped but ignore and don’t compute the adler32 …\nWrapped using the zlib format.\nThe number of bytes consumed from the input slice.\nThe number of bytes written to the output slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis module contains functionality for decompression.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an MZFlush value from an integer value.\nThe return status of the call.\nThe decompression went fine, but the adler32 checksum did …\nThe output buffer is an invalid size; consider the <code>flags</code> …\nFinished decompression without issues.\nFailed to decompress due to invalid data.\nMore input data was expected, but the caller indicated …\nThere is still pending data that didn’t fit in the …\nThe decompressor needs more input data to continue …\nReturn status codes.\nStreaming decompression functionality.\nDecompress one or more source slices from an iterator into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExtra streaming decompression functionality.\nThe mask used when indexing the base/extra arrays.\nBase length for each distance code.\nMain decompression struct.\nThe maximum length of a code that can be looked up in the …\nThe size of the fast lookup table.\nA struct containing huffman code lengths and the huffman …\nBase length for each length code.\nNumber of extra bits for each length code.\nThe length of the first (literal/length) huffman table.\nThe length of the second (distance) huffman table.\nThe length of the last (huffman code length) huffman table.\nThe number of huffman tables used.\nReturns the adler32 checksum of the currently decompressed …\nReturns the adler32 that was read from the zlib header if …\nPresumes that there is at least match_len bytes in output …\nBuffer of input data.\nThe type of the current block. or if in a dynamic block, …\n1 if the adler32 value should be checked.\nVariable used for match length, symbols, and a number of …\nTry to decode the next huffman code, and puts it in the …\nMain decompression function. Keeps decompressing data from …\nFast inner decompression loop which is run  while there is …\nCreate a new tinfl_decompressor with all fields set to 0.\nLast match distance.\nLook for a symbol in the fast lookup table. The symbol is …\nEnsure that there is data in the bit buffer.\n1 if the current block is the last block, 0 otherwise.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFlags to <code>decompress()</code> to control how inflation works.\nSet the current state to <code>Start</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHuffman length codes.\nFast lookup table for shorter huffman codes.\nLook up a symbol and code length from the bits in the …\nCreate a new tinfl_decompressor with all fields set to 0.\nNumber of bits in the bit buffer.\nNumber of extra bits for the last length or distance code.\nGet the number of extra bits used for a distance code. …\nRaw block header.\nTry to read <code>amount</code> number of bits from <code>in_iter</code> and call …\nTry to read one byte from <code>in_iter</code> and call <code>f</code> with the read …\nRead an le u16 value from the slice iterator.\nCurrent state of the decompressor.\nNumber of entries in each huffman table.\nHuffman tables.\nFull huffman tree.\nGet the symbol and the code length from the huffman tree.\nCheck that the zlib header is correct and that there is …\nAdler32 checksum from the zlib header.\nZlib CMF\nZlib FLG\nCalculate the adler32 checksum of the output data even if …\nThere will be more input that hasn’t been given to the …\nIgnore adler32 checksum even if we are inflating a zlib …\nShould we try to parse a zlib header?\nThe output buffer should not wrap around.\nA wrapper for the output slice used when decompressing.\nA wrapper for the output slice used when decompressing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWrite a byte to the current position and increment\nWrite a slice to the current position and increment\nFull reset of the state, including zeroing memory.\nA struct that compbines a decompressor with extra data for …\nResets state, without performing expensive ops (e.g. …\nTag that determines reset policy of InflateState\nResets state and zero memory, continuing to use the same …\nWhether the input data is wrapped in a zlib header and …\nInner decompressor struct\nAccess the innner decompressor.\nBuffer of input bytes for matches. TODO: Could probably do …\nHow many bytes of data to be flushed is there currently in …\nWhere in the buffer are we currently at?\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to decompress from <code>input</code> to <code>output</code> with the given …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the status of the last call to <code>inflate</code> with this …\nCreate a new state.\nPerforms reset\nReset the decompressor without re-allocating memory, using …\nResets the state according to specified policy.")