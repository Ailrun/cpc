searchState.loadedDescShard("base64", 0, "Configs\nBcrypt character set\nBinHex character set\nThe bcrypt character set (uses …\nThe character set used in BinHex 4.0 files.\nAs per <code>crypt(3)</code> requirements\nAvailable encoding character sets\nContains configuration parameters for base64 encoding\nThe <code>crypt(3)</code> character set (uses …\nErrors that can occur while decoding.\nIMAP modified UTF-7 requirements\nThe character set used in IMAP-modified UTF-7 (uses <code>+</code> and <code>,</code>…\nAn invalid byte was found in the input. The offset and …\nThe last non-padding input symbol’s encoded 6 bits have …\nThe length of the input is invalid. A typical cause of …\nStandard character set with padding.\nStandard character set without padding.\nThe standard character set (uses <code>+</code> and <code>/</code>).\nURL-safe character set with padding\nURL-safe character set without padding\nThe URL safe character set (uses <code>-</code> and <code>_</code>).\nCharacter set to use\nDecode from string reference as octets. Returns a Result …\nSets whether to emit errors for nonzero trailing bits.\nTrue to ignore excess nonzero bits in the last few …\nDecode from string reference as octets. Returns a Result …\nDecode from string reference as octets. Writes into the …\nDecode the input into the provided output slice.\nEnables base64’d output anywhere you might use a <code>Display</code> …\nEncode arbitrary octets as base64. Returns a String. …\nEncode arbitrary octets as base64. Returns a String.\nEncode arbitrary octets as base64. Writes into the …\nEncode arbitrary octets as base64. Writes into the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>Config</code>.\nSets whether to pad output with <code>=</code> characters.\nTrue to pad output with <code>=</code> characters\nImplementations of <code>io::Read</code> to transparently decode base64.\nImplementations of <code>io::Write</code> to transparently handle …\nA base64 encoder that emits encoded bytes in chunks …\nThe output mechanism for ChunkedEncoder’s encoded bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalculate the longest input that can be encoded for the …\nHandle a chunk of encoded base64 data (as UTF-8 bytes)\nErrors that can occur while decoding.\nAn invalid byte was found in the input. The offset and …\nThe last non-padding input symbol’s encoded 6 bits have …\nThe length of the input is invalid. A typical cause of …\nDecode from string reference as octets. Returns a Result …\nDecode 8 bytes of input into 6 bytes of output. 8 bytes of …\nDecode an 8-byte chunk, but only write the 6 bytes …\nDecode from string reference as octets. Returns a Result …\nDecode from string reference as octets. Writes into the …\nDecode the input into the provided output slice.\nHelper to avoid duplicating num_chunks calculation, which …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn the number of input chunks (including a possibly …\nA convenience wrapper for base64’ing bytes into a format …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>Base64Display</code> with the provided config.\nWrite padding characters. <code>output</code> is the slice where …\nEncode arbitrary octets as base64. Returns a String. …\nEncode arbitrary octets as base64. Returns a String.\nEncode arbitrary octets as base64. Writes into the …\nEncode arbitrary octets as base64. Writes into the …\nEncode input bytes to utf8 base64 bytes. Does not pad. …\nB64-encode and pad (if configured).\ncalculate the base64 encoded string size, including …\nA <code>Read</code> implementation that decodes base64 data read from …\nWhere b64 data is read from\nA <code>Read</code> implementation that decodes base64 data read from …\nDecode the requested number of bytes from the b64 buffer …\nWrite as much as possible of the decoded buffer into the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new decoder that will read from the provided …\nWhere b64 data is read from\nDecode input from the wrapped reader.\nRead into the remaining space in the buffer after the …\nA <code>Write</code> implementation that base64-encodes data using the …\nA <code>Write</code> implementation that base64 encodes data before …\nWhere encoded data is written to. It’s an Option as it’…\nHolds a partial chunk, if any, after the last <code>write()</code>, so …\nHow much of <code>extra</code> is occupied, in …\nBuffer to encode into. May hold leftover encoded bytes …\nHow much of <code>output</code> is occupied with encoded data that …\npanic safety: don’t write again in destructor if writer …\nA <code>Write</code> implementation that base64 encodes data before …\nThe most bytes whose encoding will fit in <code>BUF_SIZE</code>\nWhere encoded data is written to. It’s an Option as it’…\nHolds a partial chunk, if any, after the last <code>write()</code>, so …\nHow much of <code>extra</code> is occupied, in …\nEncode all remaining buffered data and write it, including …\nBecause this is usually treated as OK to call multiple …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new encoder that will write to the provided …\nBuffer to encode into. May hold leftover encoded bytes …\nHow much of <code>output</code> is occupied with encoded data that …\npanic safety: don’t write again in destructor if writer …\nEncode input and then write to the delegate writer.\nWrite all buffered encoded output. If this returns <code>Ok</code>, …\nWrite any remaining buffered data to the delegate writer.\nWrite as much of the encoded output to the delegate writer …\nA <code>Write</code> implementation that base64-encodes data using the …\nAn abstraction around consuming <code>str</code>s produced by base64 …\nA <code>Write</code> that only can handle bytes that are valid …\nConsume the base64 encoded data in <code>buf</code>\nCreate a EncoderStringWriter that will append to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEncode all remaining buffered data, including any trailing …\nCreate a EncoderStringWriter that will encode into a new …")