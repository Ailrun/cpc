<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Acquire a partially unsound(!!!) global re-entrant lock over backtrace’s internals."><title>lock in backtrace::lock - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="backtrace" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.1 (e71f9a9a9 2025-01-27)" data-channel="1.84.1" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../backtrace/index.html">backtrace</a><span class="version">0.3.74</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">lock</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#why" title="Why">Why</a></li><li><a href="#how" title="How">How</a></li><li><a href="#safety" title="Safety">Safety</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In backtrace::<wbr>lock</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">backtrace</a>::<wbr><a href="index.html">lock</a></span><h1>Function <span class="fn">lock</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/backtrace/lib.rs.html#222-239">Source</a> </span></div><pre class="rust item-decl"><code>pub fn lock() -&gt; <a class="struct" href="struct.LockGuard.html" title="struct backtrace::lock::LockGuard">LockGuard</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Acquire a partially unsound(!!!) global re-entrant lock over
backtrace’s internals.</p>
<p>That is, this lock can be acquired as many times as you want
on a single thread without deadlocking, allowing one thread
to acquire exclusive access to the ability to make backtraces.
Calls to this locking function are freely sprinkled in every place
where that needs to be enforced.</p>
<h2 id="why"><a class="doc-anchor" href="#why">§</a>Why</h2>
<p>This was first introduced to guard uses of Windows’ dbghelp API,
which isn’t threadsafe. It’s unclear if other things now rely on
this locking.</p>
<h2 id="how"><a class="doc-anchor" href="#how">§</a>How</h2>
<p>The basic idea is to have a single global mutex, and a thread_local
boolean saying “yep this is the thread that acquired the mutex”.</p>
<p>The first time a thread acquires the lock, it is handed a
<code>LockGuard(Some(..))</code> that will actually release the lock on Drop.
All subsequence attempts to lock on the same thread will see
that their thread acquired the lock, and get <code>LockGuard(None)</code>
which will do nothing when dropped.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>As long as you only ever assign the returned LockGuard to a freshly
declared local variable, it will do its job correctly, as the “first”
LockGuard will strictly outlive all subsequent LockGuards and
properly release the lock when the thread is done with backtracing.</p>
<p>However if you ever attempt to store a LockGuard beyond the scope
it was acquired in, it might actually be a <code>LockGuard(None)</code> that
doesn’t actually hold the lock! In this case another thread might
acquire the lock and you’ll get races this system was intended to
avoid!</p>
<p>This is why this is “partially unsound”. As a public API this would
be unacceptable, but this is crate-private, and if you use this in
the most obvious and simplistic way it Just Works™.</p>
<p>Note however that std specifically bypasses this lock, and uses
the <code>*_unsynchronized</code> backtrace APIs. This is “fine” because
it wraps its own calls to backtrace in a non-reentrant Mutex
that prevents two backtraces from getting interleaved during printing.</p>
</div></details></section></div></main></body></html>